from Matrix import *
from IQ_Polynomials import *
from Root_Of_Unity import RootOfUnity
from Permutation import Permutation
from fractions import Fraction
from itertools import product
import numpy as np
from typing import List
from Progress_Bar import printProgressBar

MAX_ELEMENT_ORDER = 1000

class SymGroup:
    def __init__(self, polynomial:IQPoly, permutations:List[Permutation]=[]):
        #verify the parameters are correct types
        if (
            not isinstance(polynomial, IQPoly) or
            not isinstance(permutations, List) or
            not all(isinstance(perm, Permutation) for perm in permutations)
        ): raise TypeError('Initialize with a IQPoly and a list of Permutation.')

        # verify that the size of the exponent matrix is the same for all of the permutations
        if not all(perm.matrix.array.shape == polynomial.exponent_matrix.array.shape for perm in permutations):
            raise ValueError('Permutations used for generating the group must be the same size as the column generators from the inverse exponent matrix')

        # the maximal symmetry group is generated by the columns of the inverse exponent matrix
        inv_exp_matrix = polynomial.inverse_exponent_matrix
        inv_exp_columns = inv_exp_matrix.transpose().array

        # turn each column into a diagonal matrix
        generators = np.concatenate((
            [perm.matrix for perm in permutations],
            [Matrix.diagonal(col) for col in inv_exp_columns]
        ))

        # groupElements, groupElementGeneratorPowers = generateGroup(generators)

        groupElements = []
        groupElementGeneratorPowers = []

        diagonalGenerators = np.array([Matrix.diagonal(col) for col in inv_exp_columns])
        diagonalGroupElements = generateGroupBetter(
            diagonalGenerators,
            groupOrder=polynomial.exponent_matrix.intDeterminant(),
            showProgress=True,
            progressMsg='Generating the diagonal subgroup'
        )

        permutationGenerators = np.array([perm.matrix for perm in permutations])
        permuationGroupElements = generateGroupBetter(
            permutationGenerators,
            showProgress=True,
            progressMsg='Generating the permutation subgroup'
        )

        if len(permuationGroupElements) == 0:
            # no permutation elements so we're done
            groupElements = diagonalGroupElements

            self.order = len(groupElements)
            self.generators = generators
            self.elements = np.array(groupElements)
            # self.conjugacyClasses = generateConjugacyClasses(groupElements)

        else:
            # the cartesian product of the diagonal group and the permutation group (while removing duplicates)
            # should be our whole group
            print('Generating the maximal group')
            totalIters = len(diagonalGroupElements) * len(permuationGroupElements)
            printProgressBar(0, totalIters, prefix = 'Progress:', suffix = f'Complete ({0}/{totalIters})', length = 50)
            for dIndex, diag in enumerate(diagonalGroupElements):
                for pIndex, perm in enumerate(permuationGroupElements):
                    elementMatrix = perm * diag
                    if elementMatrix not in groupElements:
                        groupElements.append(elementMatrix)
                    currentIter = (dIndex * len(permuationGroupElements)) + pIndex + 1
                    printProgressBar(currentIter, totalIters, prefix = 'Progress:', suffix = f'Complete ({currentIter}/{totalIters})', length = 50)


            self.order = len(groupElements)
            self.generators = generators
            self.elements = np.array(groupElements)
            # self.conjugacyClasses = generateConjugacyClasses(groupElements)

    def __repr__(self):
        return (
            f'Symmetry Group of order {self.order}\n'
        )

    def __str__(self):
        gens = '\n'.join(f'{str(gen)}\n' for gen in self.generators)
        elems = '\n'.join(f'{elem}  {pows}\n' for elem, pows in zip(self.elements, self.element_generator_representation))
        return (
            f'Symmetry Group of order {self.order}\n'
            '\n~~~~~~~~~Generators~~~~~~~~~\n'
            f'{gens}'
            '\n~~~~~~~~~~Elements~~~~~~~~~~\n'
            f'{elems}'
        )





def getOrderOfElement(element:Matrix):
    a = np.empty(len(element.array), dtype=object)
    a.fill(RootOfUnity(Fraction()))
    identity_matrix = Matrix.diagonal(a)


    order = 1
    power = element.copy()
    while power != identity_matrix:
        power = power * element
        order += 1

        if order > MAX_ELEMENT_ORDER:
            raise ValueError('Cannot calcuate the order of the element. Order exceeded MAX_ELEMENT_ORDER.')
    
    return order

def generateGroup(generators, groupOrder = None, showProgress = False, progressMsg = None):

    if len(generators) == 0:
        return [], []

    # get the order of each generator
    generatorOrders = [getOrderOfElement(elem) for elem in generators]

    #create the list of cartesian products for the powers possible for the generating the group
    #this outputs a list of integers that are used as powers on the generators
    iterableList = []
    for elementOrder in generatorOrders:
        iterableSet = [*range(1, elementOrder + 1)]
        iterableList.append(iterableSet)
    cartesianProduct = list(product(*iterableList))

    #use the cartesian product elements to calculate the group elements
    #save both the actual matrix and the generator products representation
    groupElements = []
    groupElementGeneratorPowers = []
    totalIters = groupOrder if groupOrder != None else len(cartesianProduct)
    if showProgress:
        if progressMsg != None:
            print(progressMsg)
        printProgressBar(0, totalIters, prefix = 'Progress:', suffix = f'Complete ({0}/{totalIters})', length = 50)
    for cIndex, elementPowers in enumerate(cartesianProduct):
        # if we have all of the elements already, break
        if (groupOrder != None and len(groupElements) == groupOrder):
            break

        # set up the identity matrix with roots of unity
        a = np.empty(len(generators[0].array), dtype=object)
        a.fill(RootOfUnity(Fraction()))
        identity_matrix = Matrix.diagonal(a)

        # run through the generators and build the element
        elementMatrix = identity_matrix
        generatorRepr = []
        for pIndex, power in enumerate(elementPowers):
            elementMatrix *= generators[pIndex]**power
            generatorRepr.append(power)
        if elementMatrix not in groupElements:
            groupElements.append(elementMatrix)
            groupElementGeneratorPowers.append(generatorRepr)

        if showProgress:
            if groupOrder != None:
                printProgressBar(len(groupElements), totalIters, prefix = 'Progress:', suffix = f'Complete ({len(groupElements)}/{totalIters})', length = 50)
            else:
                printProgressBar(cIndex + 1, totalIters, prefix = 'Progress:', suffix = f'Complete ({cIndex + 1}/{totalIters})', length = 50)

    return groupElements, groupElementGeneratorPowers
    
def generateGroupBetter(generators, groupOrder = None, showProgress = False, progressMsg = None):
    if len(generators) == 0:
        return []
    
    groupElements = []
    totalIters = len(generators)
    if showProgress:
        if progressMsg != None:
            print(progressMsg)
        printProgressBar(0, totalIters, prefix = 'Progress:', suffix = f'Complete ({0}/{totalIters})', length = 50)
    for index, generator in enumerate(generators):
        powers = getAllElementPowers(generator)
        newElements = getAllProducts(groupElements, powers)
        groupElements += newElements
        if (len(groupElements) == groupOrder):
            return groupElements

        if showProgress:   
            printProgressBar(index + 1, totalIters, prefix = 'Progress:', suffix = f'Complete ({index + 1}/{totalIters})', length = 50)

    return groupElements

def generateConjugacyClasses(elements):
    tmpElements = elements.copy()
    conjugacyClasses = []
    iterationNum = 0
    totalIterations = len(elements)
    
    print('Generating the conjugacy classes')
    printProgressBar(0, totalIterations, prefix = 'Progress:', suffix = f'Complete ({0}/{totalIterations})', length = 50)
    while (len(tmpElements) > 0):
        currentElement = tmpElements[0]
        currentConjugacyClass = []
        for element in elements:
            conjugate = element * currentElement * element.verySlow_rootOfUnityInverse()
            if conjugate not in currentConjugacyClass:
                currentConjugacyClass.append(conjugate)
                tmpElements.remove(conjugate)
                iterationNum += 1
                printProgressBar(iterationNum, totalIterations, prefix = 'Progress:', suffix = f'Complete ({iterationNum}/{totalIterations})', length = 50)
        conjugacyClasses.append(currentConjugacyClass)
    
    return conjugacyClasses




def getAllElementPowers(element):
    order = getOrderOfElement(element)

    generatedElements = [element]
    for power in range(2, order + 1):
        generatedElements.append(generatedElements[-1] * element)
    
    return generatedElements
    
def getAllProducts(setA, setB):
    if len(setA) == 0:
        return setB
    if len(setB) == 0:
        return setA

    totalIters = len(setA) * len(setB)

    groupElements = []
    # printProgressBar(0, totalIters, prefix = 'Progress:', suffix = f'Complete (0/{totalIters})', length = 50)
    for indexA, elementA in enumerate(setA):
        for indexB, elementB in enumerate(setB):
            element = elementA * elementB
            if element not in groupElements:
                groupElements.append(element)
            currentIter = (indexA * len(setB)) + indexB + 1
            # printProgressBar(currentIter, totalIters, prefix = 'Progress:', suffix = f'Complete ({currentIter}/{totalIters})', length = 50)
    
    return groupElements